import{_ as l,c as i,o as e,a2 as a}from"./chunks/framework.Bx6qu0xe.js";const t="/assets/image_redis.DHUqwjZQ.png",m=JSON.parse('{"title":"Redis","description":"","frontmatter":{"layout":"doc","title":"Redis"},"headers":[],"relativePath":"note/Redis.md","filePath":"note/Redis.md"}'),s={name:"note/Redis.md"},r=a('<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h1><h2 id="_1-redis的使用场景" tabindex="-1">1.Redis的使用场景 <a class="header-anchor" href="#_1-redis的使用场景" aria-label="Permalink to &quot;1.Redis的使用场景&quot;">​</a></h2><ul><li>根据简历上的项目进行回答</li><li>缓存（穿透、击穿、雪崩、双写一致、持久化、数据过期、淘汰策略）</li><li>分布式锁（setnx、redisson）</li></ul><h2 id="_2-什么是缓存穿透-怎么解决" tabindex="-1">2.什么是缓存穿透，怎么解决 <a class="header-anchor" href="#_2-什么是缓存穿透-怎么解决" aria-label="Permalink to &quot;2.什么是缓存穿透，怎么解决&quot;">​</a></h2><ul><li>缓存穿透：查询一个不存在的key，MySQL查询不到也不会写入Redis，导致每次请求都调用数据库</li><li>解决方案1：缓存空数据、实现简单，Redis压力大</li><li>解决方案2：布隆过滤器、实现复杂，缓存预热记录布隆过滤器</li></ul><h2 id="_3-什么是缓存击穿-怎么解决" tabindex="-1">3.什么是缓存击穿，怎么解决 <a class="header-anchor" href="#_3-什么是缓存击穿-怎么解决" aria-label="Permalink to &quot;3.什么是缓存击穿，怎么解决&quot;">​</a></h2><ul><li>缓存击穿：给某一个key设置了过期时间，过期期间大量并发请求进入，压垮数据库</li><li>解决方案1：互斥锁、强一致、性能差</li><li>解决方案2：逻辑过期、高可用、不能保证数据绝对一致</li></ul><h2 id="_4-什么是缓存雪崩-怎么解决" tabindex="-1">4.什么是缓存雪崩，怎么解决 <a class="header-anchor" href="#_4-什么是缓存雪崩-怎么解决" aria-label="Permalink to &quot;4.什么是缓存雪崩，怎么解决&quot;">​</a></h2><ul><li>缓存雪崩：同一时间段大量key同时过期或Redis服务器宕机，导致大量请求打到数据库</li><li>解决方案1：随机Ttl值</li><li>解决方案2：Redis集群</li><li>解决方案3：限流降级 nginx、spring-cloud-gateway</li><li>解决方案4：多级缓存 Guava、Caffeine</li></ul><h2 id="_5-redis缓存如何与mysql进行数据同步-双写一致" tabindex="-1">5.Redis缓存如何与MySQL进行数据同步（双写一致） <a class="header-anchor" href="#_5-redis缓存如何与mysql进行数据同步-双写一致" aria-label="Permalink to &quot;5.Redis缓存如何与MySQL进行数据同步（双写一致）&quot;">​</a></h2><ul><li>先介绍业务</li><li>一致性要求高（强一致）</li><li>允许延迟一致</li></ul><ol><li><p>延时双删</p><ol><li>先删除缓存还是先删除数据库</li><li>为什么删除2此缓存</li><li>为什么要延时删除</li></ol></li><li><p>读多写少：读时添加共享锁（readLock），写时添加排他锁（writeLock）</p></li><li><p>异步通知保证最终一致性</p><ol><li>MQ：更新数据后，消息通知缓存删除</li><li>Canal：读取binlog日志更新缓存</li></ol></li></ol><h2 id="_6-redis数据持久化" tabindex="-1">6.Redis数据持久化 <a class="header-anchor" href="#_6-redis数据持久化" aria-label="Permalink to &quot;6.Redis数据持久化&quot;">​</a></h2><ol><li>RDB（数据快照）：把内存中所有数据文件记录到磁盘，Redis启动从磁盘快照恢复数据 <img src="'+t+'" alt="alt text"></li><li>AOF（追加文件）：把Redis的每一个命令记录在AOF文件</li></ol><h2 id="_7-redis数据过期策略" tabindex="-1">7.Redis数据过期策略 <a class="header-anchor" href="#_7-redis数据过期策略" aria-label="Permalink to &quot;7.Redis数据过期策略&quot;">​</a></h2><ol><li>惰性删除：需要key的时候检查是否过期，如果过期则删掉，否则返回key <ul><li>优点：CPU消耗小，只会在使用时过期检查</li><li>缺点：内存不友好，如果一个key一直不使用，那么这个key会一直存在内存中，内存不会释放</li></ul></li><li>定期删除：每隔一段时间，对一些key检查，删除过期的key <ul><li>SLOW：定时任务，每秒10次，每次不超过25ms</li><li>FAST：执行频率不固定，间隔不低于2ms，每次耗时不超过1ms</li></ul></li></ol><p>实际上Redis是惰性删除、定期删除两种结合使用</p><h2 id="_8-redis数据淘汰策略" tabindex="-1">8.Redis数据淘汰策略 <a class="header-anchor" href="#_8-redis数据淘汰策略" aria-label="Permalink to &quot;8.Redis数据淘汰策略&quot;">​</a></h2><p>当Redis内存不够用的时候，继续往Redis添加数据，那么Redis会按照一定的规则将内存中的数据删掉，这种删除的规则被称为内存的淘汰策略 Redis支持8钟不同的策略来选择要删除的key：</p><ul><li>noeviction：不淘汰任何key，内存满时不允许写入任何新数据，默认时这种策略</li><li>volatile-ttl：对设置了ttl的key比较ttl，ttl越小越先淘汰</li><li>allkeys-random：对全体key随机淘汰</li><li>volatile-random：对设置了ttl的key，随机进行淘汰</li><li>allkeys-lru：对全体key，基于lru进行淘汰</li><li>volatile-lru：对设置了ttl的key，基于lru淘汰</li><li>allkeys-lfu：对所有key，基于lfu淘汰</li><li>volatile-lfu：对设置了ttl的key，基于lfu淘汰</li></ul><h2 id="_9-redis集群方案" tabindex="-1">9.Redis集群方案 <a class="header-anchor" href="#_9-redis集群方案" aria-label="Permalink to &quot;9.Redis集群方案&quot;">​</a></h2><ol><li>主从</li><li>哨兵</li><li>分片</li></ol><h2 id="_10-redis是单线程的-为什么会这么快" tabindex="-1">10.Redis是单线程的，为什么会这么快？ <a class="header-anchor" href="#_10-redis是单线程的-为什么会这么快" aria-label="Permalink to &quot;10.Redis是单线程的，为什么会这么快？&quot;">​</a></h2><ul><li>Redis是纯内存操作，执行速度非常快</li><li>采用单线程，避免不必要的线程上下文切换竞争，多线程还需要考虑线程安全问题</li><li>使用I/O多路复用模型，非阻塞I/O <ul><li>Redis是纯内存操作，执行速度非常快，主要性能瓶颈是网络延时而不是执行速度，I/O多路复用模型就是为了实现高效网络请求</li><li>利用单个线程同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效等待，充分利用CPU资源</li></ul></li></ul>',24),d=[r];function o(n,h,u,c,_,k){return e(),i("div",null,d)}const y=l(s,[["render",o]]);export{m as __pageData,y as default};
