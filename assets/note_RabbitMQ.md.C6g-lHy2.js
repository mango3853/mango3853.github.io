import{_ as e,c as a,o as i,a2 as o}from"./chunks/framework.Bx6qu0xe.js";const q=JSON.parse('{"title":"redis","description":"","frontmatter":{"layout":"doc","title":"redis"},"headers":[],"relativePath":"note/RabbitMQ.md","filePath":"note/RabbitMQ.md"}'),t={name:"note/RabbitMQ.md"},l=o('<p>Producer(生产者) :生产消息的一方（邮件投递者） Consumer(消费者) :消费消息的一方（邮件收件人）</p><h1 id="exchange-交换器" tabindex="-1">Exchange (交换器) <a class="header-anchor" href="#exchange-交换器" aria-label="Permalink to &quot;Exchange (交换器)&quot;">​</a></h1><p>在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。</p><p>RabbitMQ 中通过 Binding(绑定) 将 Exchange(交换器) 与 Queue(消息队列) 关联起来，在绑定的时候一般会指定一个 BindingKey(绑定建) ,这样 RabbitMQ 就知道如何正确将消息路由到队列了。</p><h1 id="queue-消息队列" tabindex="-1">Queue (消息队列) <a class="header-anchor" href="#queue-消息队列" aria-label="Permalink to &quot;Queue (消息队列)&quot;">​</a></h1><p>Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p><h1 id="broker-消息中间件的服务节点" tabindex="-1">Broker（消息中间件的服务节点） <a class="header-anchor" href="#broker-消息中间件的服务节点" aria-label="Permalink to &quot;Broker（消息中间件的服务节点）&quot;">​</a></h1><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p><h1 id="message-消息" tabindex="-1">Message (消息) <a class="header-anchor" href="#message-消息" aria-label="Permalink to &quot;Message (消息)&quot;">​</a></h1><p>消息一般由 2 部分组成：消息头（或者说是标签 Label）和 消息体。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p><h2 id="exchange-types-交换器类型" tabindex="-1">Exchange Types(交换器类型) <a class="header-anchor" href="#exchange-types-交换器类型" aria-label="Permalink to &quot;Exchange Types(交换器类型)&quot;">​</a></h2><ol><li><p>fanout</p><blockquote><p>fanout 会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p></blockquote></li><li><p>direct</p><blockquote><p>direct 类型的 Exchange 会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p></blockquote></li><li><p>topic</p><blockquote><p>topic 模糊匹配 使用点号 ‘.’ 分割</p></blockquote><p>BindingKey 中可以存在两种特殊字符串 “<em>” 和 “#” ，用于做模糊匹配，其中“</em>” 用于匹配一个单词，“#” 用于匹配多个单词(可以是零个)。</p></li><li><p>headers</p><blockquote><p>根据消息中的headers属性，进行键值对匹配</p></blockquote></li></ol><h2 id="消息丢失" tabindex="-1">消息丢失 <a class="header-anchor" href="#消息丢失" aria-label="Permalink to &quot;消息丢失&quot;">​</a></h2><ol><li><p>消息未到达交换机</p></li><li><p>消息未到达队列</p></li><li><p>消费者未收到消息</p></li></ol><h3 id="生产者确认机制" tabindex="-1">生产者确认机制 <a class="header-anchor" href="#生产者确认机制" aria-label="Permalink to &quot;生产者确认机制&quot;">​</a></h3><p>RabbitMq提供了publisher confirm机制避免消息发送到MQ过程中丢失。消息发送到MQ之后，会返回一个结果给发送者，表示消息是否处理成功</p><ul><li>回调方法重发</li><li>记录日志</li><li>保存到数据库定时重发，成功后删掉表中的数据</li></ul><h3 id="mq宕机" tabindex="-1">MQ宕机 <a class="header-anchor" href="#mq宕机" aria-label="Permalink to &quot;MQ宕机&quot;">​</a></h3><p>MQ默认是内存存储消息，可以开启消息持久化功能确保缓存在MQ中的消息不丢失</p><ol><li>交换机持久化 <code>new DirectExchange(&quot;simple.direct&quot;, true, false)</code></li><li>队列持久化 <code>QueueBuilder.durable(&quot;simple.queue&quot;).build()</code></li><li>消息持久化 <code>MessageBuilder.withBody().setDeliverMode(MessageDeliverMode.PERSISTENT).build()</code></li></ol><h3 id="消费者确认机制" tabindex="-1">消费者确认机制 <a class="header-anchor" href="#消费者确认机制" aria-label="Permalink to &quot;消费者确认机制&quot;">​</a></h3><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后向MQ发送ack回执，MQ收到ack回执后才会删除该消息</p><ul><li>manual：手动ack，业务代码执行完成后，调用api发送ack。</li><li>auto：自动ack，由spring监测listener是否发生异常，没有异常返回ack，否则返回nack。</li><li>none：关闭ack，MQ假定消费者获取到消息后会成功处理，因此消息投递后立即删除</li></ul><p>利用Spring的retry机制，在消费者出现异常的时候本地重试，设置重试次数，当重试次数达到后，将消息发送给异常交换机，由人工手动处理</p><h2 id="消息重复消费" tabindex="-1">消息重复消费 <a class="header-anchor" href="#消息重复消费" aria-label="Permalink to &quot;消息重复消费&quot;">​</a></h2><ul><li>业务标识唯一ID</li><li>幂等方案：分布式锁、数据库锁</li></ul>',27),r=[l];function n(u,c,d,h,p,b){return i(),a("div",null,r)}const k=e(t,[["render",n]]);export{q as __pageData,k as default};
